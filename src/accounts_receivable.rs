use crate::{create_matcher_wrapper, inventory::Item, wait, SHORT_WAIT_MS};
use csv::ReaderBuilder;
use uiautomation::{types::UIProperty, UIAutomation, UIElement};

/// An *invoice* is the record of a transaction from the Accounts Receivable screen in ABC
#[derive(Debug, PartialEq)]
pub struct Invoice {
    /// The unique identifier for this invoice
    pub number: usize,

    /// The date the invoice was made
    pub date: chrono::NaiveDate,

    /// The unique identifier for the customer the invoice is for
    pub customer_id: String,

    /// A list of all items on the transaction as well as the quantity of each
    pub line_items: Vec<(Item, isize)>,
}

impl Invoice {
    /// Create a blank, default `Invoice` with the follow fields and values { number: 0, date:
    /// NaiveDate::MIN, customer_id: "", line_items: [] }
    pub fn new() -> Invoice {
        Invoice {
            number: 0,
            date: chrono::NaiveDate::MIN,
            customer_id: String::new(),
            line_items: Vec::new(),
        }
    }

    /// Parse tabbed output from the 3-13 ABC report into a list of `Invoices`
    ///
    /// # Arguments 
    ///
    /// * `tsv_txt` - The string value of the TabbedOutput.tsv file generated by the 3-13 report 
    ///
    /// # Returns 
    ///
    /// Will return a list of `Invoices` parsed from `tsv_txt` in the order they appear in the text
    ///
    /// # Errors 
    ///
    /// Will return `csv::Error` if `tsv_txt` cannot be parsed. This is likely because the text is
    /// not properly formatted tab separated values
    pub fn parse_from_tsv(tsv_txt: &str) -> Result<Vec<Self>, csv::Error> {
        let mut rdr = ReaderBuilder::new()
            .has_headers(false)
            .delimiter(b'\t')
            .flexible(true)
            .from_reader(tsv_txt.as_bytes());

        let mut invoices: Vec<Invoice> = Vec::new();
        let mut current_invoice = Invoice::new();
        while let Some(result) = rdr.records().next() {
            let record = result?;
            if let Some(col) = record.get(1) {
                if col.to_uppercase().contains("INVOICE #") {
                    current_invoice = Invoice::new();
                    let invoice_string = col[11..].to_string();
                    current_invoice.number = invoice_string.parse().unwrap_or(0);
                    current_invoice.customer_id = record.get(58).unwrap_or(".CASH").to_string();
                    current_invoice.date = chrono::NaiveDate::parse_from_str(
                        record.get(65).unwrap_or("1/ 1/70"),
                        "%m/%-d/%y",
                    )
                    .unwrap_or(chrono::NaiveDate::MIN);
                    continue;
                }
            }

            if let Some(col) = record.get(6) {
                if col.contains("----------") {
                    invoices.push(current_invoice);
                    current_invoice = Invoice::new();
                    rdr.records().next();
                    continue;
                }
            }

            let mut quantity = 1isize;
            let mut item = Item::new();
            if let Some(col) = record.get(1) {
                quantity = col.to_string().parse().unwrap_or(1);
            }

            if let Some(col) = record.get(3) {
                item.sku = col.to_string();
            }

            if let Some(col) = record.get(4) {
                item.description = Some(col.to_string());
            }

            if let Some(col) = record.get(8) {
                item.list = col.to_string().parse().unwrap_or(0f32) / quantity as f32;
            }

            if item != Item::new() {
                current_invoice.line_items.push((item, quantity));
            }
        }

        Ok(invoices)
    }
}

/// Control the ABC Client4 window to load the Invoices records screen, and return the `UIElement`
/// that represents that screen.
///
/// # Arguments
///
/// * `abc_window` - Reference to the `UIElement` representing the Client4 window. The easiest way
/// to get this value is to call `abc_controller::load_abc`
///
/// # Returns
///
/// If successful, return the `UIElement` that represents the Invoices screen. This is a control
/// inside Client4 whose name contains "Sales - Invoices (R)"
///
/// If any key combos fail to send or if the invoices screen cannot be found, return
/// `Err(uiautomation::Error)`
///
/// # Errors
///
/// If any key combos fail to send or if the invoices screen cannot be found, return
/// `Err(uiautomation::Error)`
pub fn load_invoices_screen(abc_window: &UIElement) -> uiautomation::Result<UIElement> {
    let automation = UIAutomation::new()?;

    if let Ok(invoices_screen) = create_matcher_wrapper(&automation)?
        .contains_name("Sales - Invoices (R)")
        .find_first()
    {
        return Ok(invoices_screen);
    }

    abc_window.send_keys("{F10}R", SHORT_WAIT_MS * 3)?;

    create_matcher_wrapper(&automation)?
        .contains_name("Sales - Invoices (R)")
        .find_first()
}

/// Loads an invoice identified by its number into the provided invoices window.
///
/// # Arguments
///
/// * `invoices_window` - A reference to a UI element (e.g., ABC (R) screen or Accounts Receivable Screen)
///   containing invoice details.
/// * `invoice_num` - The unique identifier of the invoice to be loaded.
///
/// # Returns
///
/// A `Result` indicating the success or failure of loading the invoice.
/// If successful, returns `Ok(())`.
/// If any UI element is not found or if there are errors during the loading process,
/// returns an `Err` with a specific error code and message.
///
/// # Errors
///
/// * Returns an error if it fails to find the UI element representing the invoice number control.
/// * Returns an error if there are issues during the UI automation process.
///
/// # Examples
///
/// ```rust
/// use uiautomation::UIElement;
///
/// // Assuming `invoices_window` and `invoice_num` are properly initialized
/// let loading_result = load_invoice(&invoices_window, 123);
/// match loading_result {
///     Ok(_) => println!("Invoice successfully loaded."),
///     Err(err) => println!("Error: {}", err),
/// }
/// ```
pub fn load_invoice(invoices_window: &UIElement, invoice_num: u64) -> uiautomation::Result<()> {
    let automation = UIAutomation::new()?;

    let invoice_num_control = create_matcher_wrapper(&automation)?
        .classname("ThunderRT6TextBox")
        .from(invoices_window.to_owned())
        .find_first()?;
    invoice_num_control.click()?;
    invoice_num_control.send_keys(&format!("{}{{enter}}", invoice_num), SHORT_WAIT_MS)?;

    Ok(())
}

/// Sends an invoice to JDF (John Deere Financial) and checks if the operation was successful.
///
/// # Arguments
///
/// * `invoices_window` - A reference to the ABC (R) Accounts Receivable screen. This is most
/// easily obtained by running `load_invoices_screen`
/// * `invoice_num` - The unique identifier of the invoice being sent to JDF.
///
/// # Returns
///
/// A `Result` indicating whether the invoice was successfully sent to JDF (`true`) or not (`false`).
/// If successful, returns `Ok(true)` if the invoice was sent to JDF or `Ok(false)` if not sent.
/// If any UI element is not found or if there are errors during the process, returns an `Err` with a specific error code and message.
///
/// # Errors
///
/// * Returns an error if it fails to find the UI element representing the paid control.
/// * Returns an error if there are issues during the UI automation process.
///
/// # Examples
///
/// ```rust
/// use uiautomation::UIElement;
///
/// // Assuming `invoices_window` and `invoice_num` are properly initialized
/// let jdf_result = send_invoice_to_jdf(&invoices_window, 123);
/// match jdf_result {
///     Ok(true) => println!("Invoice successfully sent to JDF."),
///     Ok(false) => println!("Failed to send invoice to JDF."),
///     Err(err) => println!("Error: {}", err),
/// }
/// ```
pub fn send_invoice_to_jdf(
    invoices_window: &UIElement,
    invoice_num: u64,
) -> uiautomation::Result<bool> {
    let automation = UIAutomation::new()?;

    load_invoice(invoices_window, invoice_num)?;
    let all_text_boxes = create_matcher_wrapper(&automation)?
        .from(invoices_window.to_owned())
        .classname("ThunderRT6TextBox")
        .find_all()?;
    let paid_control = match all_text_boxes.get(29) {
        Some(c) => c,
        None => return Err(uiautomation::Error::new(2, "could not find paid control")),
    };
    let paid_control_value = paid_control
        .get_property_value(UIProperty::ValueValue)?
        .get_string()?;
    if paid_control_value != String::new() {
        return Ok(true);
    }

    invoices_window.send_keys("{F9}7R", SHORT_WAIT_MS * 3)?;
    wait(2000);

    let invoice_num_control = create_matcher_wrapper(&automation)?
        .classname("ThunderRT6TextBox")
        .from(invoices_window.to_owned())
        .find_first()?;
    let invoice_num_control_value = invoice_num_control
        .get_property_value(UIProperty::ValueValue)?
        .get_string()?;
    if invoice_num.to_string() == invoice_num_control_value {
        invoices_window.send_keys("{enter}{esc}", SHORT_WAIT_MS * 3)?;
        invoices_window.hold_send_keys("{ctrl}", "n", SHORT_WAIT_MS * 3)?;
        invoices_window.send_keys("{right}{enter}", SHORT_WAIT_MS * 3)?;
        return Ok(false);
    }

    Ok(true)
}

/// Checks if an invoice is fully paid by comparing values extracted from specific UI elements.
///
/// # Arguments
///
/// * `invoices_window` - A reference to a UI element containing invoice details.
/// * `invoice_num` - The unique identifier of the invoice being checked.
///
/// # Returns
///
/// A `Result` indicating whether the invoice is fully paid (`true`) or not (`false`).
/// If successful, returns `Ok(true)` if the paid amount matches the total amount; otherwise, `Ok(false)`.
/// If any UI element is not found or if there are errors, returns an `Err` with a specific error code and message.
///
/// # Errors
///
/// * Returns an error if it fails to find the UI element representing the paid amount.
/// * Returns an error if it fails to find the UI element representing the total amount.
///
/// # Examples
///
/// ```rust
/// use uiautomation::UIElement;
///
/// // Assuming `invoices_window` and `invoice_num` are properly initialized
/// let is_fully_paid = is_invoice_fully_paid(&invoices_window, 123);
/// match is_fully_paid {
///     Ok(true) => println!("The invoice is fully paid."),
///     Ok(false) => println!("The invoice is not fully paid."),
///     Err(err) => println!("Error: {}", err),
/// }
/// ```
pub fn is_invoice_fully_paid(
    invoices_window: &UIElement,
    invoice_num: u64,
) -> uiautomation::Result<bool> {
    let automation = UIAutomation::new()?;

    load_invoice(invoices_window, invoice_num)?;
    let all_text_boxes = create_matcher_wrapper(&automation)?
        .from(invoices_window.to_owned())
        .classname("ThunderRT6TextBox")
        .find_all()?;
    let paid_control = match all_text_boxes.get(29) {
        Some(c) => c,
        None => return Err(uiautomation::Error::new(2, "could not find paid control")),
    };
    let total_control = match all_text_boxes.get(38) {
        Some(c) => c,
        None => {
            return Err(uiautomation::Error::new(
                2,
                "could not find invoice total control",
            ))
        }
    };
    let paid_control_value = paid_control
        .get_property_value(UIProperty::ValueValue)?
        .get_string()?;
    let total_control_value = total_control
        .get_property_value(UIProperty::ValueValue)?
        .get_string()?;

    Ok(paid_control_value == total_control_value)
}

#[cfg(test)]
mod tests {
    use chrono::NaiveDate;

    use crate::inventory::Item;

    use super::Invoice;

    #[test]
    fn test_from_tsv() {
        let tsv_txt = "	  INVOICE #540970			STORE NAME		PO BOX 123		123 STREET ADR		CITY ST  12345		(123)456-7890													Cash Sale																		-------------------------------------------------------------------------------	CUST.CODE		CUST.P/O#		SHIP VIA		SLS		TAX CODE		TERMS		  INVOICE	DATE	.CASH				PA		CASH	12/ 6/24		-------------------------------------------------------------------------------		QUANTITY  ITEM #     DESCRIPTION                                      SELL PRICE       AMOUNT	
 	3	 	PURSTRATEGYH	STRATEGY HEALTHY EDGE		25.00	EA	75.00	T		
 	4	 	SS137386	3' PRM MINI FLAKE SHAVINGS BEDDING		10.00		40.00	T	
 	-1	 	SS379776	QT GLAZING COMPOUND		11.24	EA	-11.24		
 	12	 	FAST	MIDWEST FASTENERS		.20	EA	2.40	T		
 	1	 	SS764720	GAL RAINX WINDOW WASH FLUID		5.49		5.49	T		
                     AMERICAS CHOICE	
 		 	PA	SALES TAX on $115.00			%	6.90			















































						--------------------------------------------------------------------------------			TOTAL INVOICE:	121.90	
X1234 Auth:012345 Seq:1234567890 x____________________________	Amount:	121.90";

        let parsed_invoices = Invoice::parse_from_tsv(tsv_txt).unwrap();

        let line_items: Vec<(Item, isize)> = vec![
            (
                Item {
                    sku: "PURSTRATEGYH".to_string(),
                    description: Some("STRATEGY HEALTHY EDGE".to_string()),
                    list: 25.0,
                    cost: 0.0,
                    vendor_id: None,
                    upc: None,
                },
                3,
            ),
            (
                Item {
                    sku: "SS137386".to_string(),
                    description: Some("3' PRM MINI FLAKE SHAVINGS BEDDING".to_string()),
                    list: 10.0,
                    cost: 0.0,
                    vendor_id: None,
                    upc: None,
                },
                4,
            ),
            (
                Item {
                    sku: "SS379776".to_string(),
                    description: Some("QT GLAZING COMPOUND".to_string()),
                    list: 11.24,
                    cost: 0.0,
                    vendor_id: None,
                    upc: None,
                },
                -1,
            ),
            (
                Item {
                    sku: "FAST".to_string(),
                    description: Some("MIDWEST FASTENERS".to_string()),
                    list: 0.20,
                    cost: 0.0,
                    vendor_id: None,
                    upc: None,
                },
                12,
            ),
            (
                Item {
                    sku: "SS764720".to_string(),
                    description: Some("GAL RAINX WINDOW WASH FLUID".to_string()),
                    list: 5.49,
                    cost: 0.0,
                    vendor_id: None,
                    upc: None,
                },
                1,
            ),
            (
                Item {
                    sku: "PA".to_string(),
                    description: Some("SALES TAX on $115.00".to_string()),
                    list: 6.9,
                    cost: 0.0,
                    vendor_id: None,
                    upc: None,
                },
                1,
            ),
        ];
        let test_invoice = Invoice {
            number: 540970,
            date: NaiveDate::from_ymd_opt(2024, 12, 6).unwrap(),
            customer_id: ".CASH".to_string(),
            line_items,
        };

        assert_eq!(vec![test_invoice], parsed_invoices);
    }
}
